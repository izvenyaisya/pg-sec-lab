package generator

import (
	"fmt"
	"strings"

	"pg-sec-lab/internal/policy"
)

func GenerateSQL(p *policy.Policy) (string, error) {
	var sb strings.Builder

	sb.WriteString("-- Generated by pg-sec-lab\n")
	sb.WriteString(fmt.Sprintf("-- System: %s, Version: %s\n\n", p.Metadata.System, p.Metadata.Version))

	rolesSQL := generateRoles(p)
	sb.WriteString(rolesSQL)
	sb.WriteString("\n")

	rlsSQL := generateTablesRLS(p)
	sb.WriteString(rlsSQL)
	sb.WriteString("\n")

	masksSQL := generateMasks(p)
	sb.WriteString(masksSQL)
	sb.WriteString("\n")

	grantsSQL := generateGrants(p)
	sb.WriteString(grantsSQL)

	return sb.String(), nil
}

func generateRoles(p *policy.Policy) string {
	var sb strings.Builder
	sb.WriteString("-- Create roles\n")

	// First, create all roles
	for roleName, role := range p.Roles {
		// Use DO block to check if role exists
		sb.WriteString("DO $$\nBEGIN\n")
		sb.WriteString(fmt.Sprintf("    IF NOT EXISTS (SELECT FROM pg_roles WHERE rolname = '%s') THEN\n", roleName))
		sb.WriteString(fmt.Sprintf("        CREATE ROLE %s", pqQuoteIdent(roleName)))

		if role.Login {
			sb.WriteString(" LOGIN")
		} else {
			sb.WriteString(" NOLOGIN")
		}

		if role.CanCreateDB {
			sb.WriteString(" CREATEDB")
		} else {
			sb.WriteString(" NOCREATEDB")
		}

		sb.WriteString(";\n")
		sb.WriteString("    END IF;\n")
		sb.WriteString("END $$;\n")
	}

	// Then, grant memberships
	for roleName, role := range p.Roles {
		if len(role.Members) > 0 {
			for _, member := range role.Members {
				sb.WriteString(fmt.Sprintf("GRANT %s TO %s;\n",
					pqQuoteIdent(roleName), pqQuoteIdent(member)))
			}
		}
	}

	return sb.String()
}

func generateTablesRLS(p *policy.Policy) string {
	var sb strings.Builder
	sb.WriteString("-- Enable RLS on tables\n")

	for tableName, tp := range p.Tables {
		if !tp.RLS.Enabled {
			continue
		}

		schema, table := splitObject(tableName)
		fullName := fmt.Sprintf("%s.%s", pqQuoteIdent(schema), pqQuoteIdent(table))

		sb.WriteString(fmt.Sprintf("ALTER TABLE %s ENABLE ROW LEVEL SECURITY;\n", fullName))
		sb.WriteString(fmt.Sprintf("ALTER TABLE %s FORCE ROW LEVEL SECURITY;\n", fullName))

		policyName := fmt.Sprintf("rls_select_%s", table)
		sb.WriteString(fmt.Sprintf("CREATE POLICY %s ON %s FOR SELECT USING (%s);\n",
			pqQuoteIdent(policyName), fullName, tp.RLS.SelectPolicy))
	}

	return sb.String()
}

func generateMasks(p *policy.Policy) string {
	var sb strings.Builder
	sb.WriteString("-- Create masked views\n")

	for tableName, tp := range p.Tables {
		if len(tp.Masks) == 0 {
			continue
		}

		schema, table := splitObject(tableName)

		maskedColumns := make(map[string]string)
		for _, mask := range tp.Masks {
			maskedColumns[mask.Column] = mask.Expression
		}

		var viewName string
		if len(tp.Masks) > 0 {
			viewName = tp.Masks[0].ExposedAs
		}

		sb.WriteString(fmt.Sprintf("CREATE OR REPLACE VIEW %s AS\n", pqQuoteIdent(viewName)))
		sb.WriteString("SELECT\n")

		sb.WriteString("  id,\n")
		sb.WriteString("  tenant_id,\n")

		for col, expr := range maskedColumns {
			sb.WriteString(fmt.Sprintf("  %s AS %s", expr, pqQuoteIdent(col)))
		}

		sb.WriteString(fmt.Sprintf("\nFROM %s.%s;\n", pqQuoteIdent(schema), pqQuoteIdent(table)))
	}

	return sb.String()
}

func generateGrants(p *policy.Policy) string {
	var sb strings.Builder
	sb.WriteString("-- Grant privileges\n")

	for roleName, role := range p.Roles {
		for _, priv := range role.Privileges {
			schema, table := splitObject(priv.Object)
			fullName := fmt.Sprintf("%s.%s", pqQuoteIdent(schema), pqQuoteIdent(table))

			actions := strings.Join(priv.Actions, ", ")
			sb.WriteString(fmt.Sprintf("GRANT %s ON %s TO %s;\n",
				actions, fullName, pqQuoteIdent(roleName)))
		}
	}

	return sb.String()
}

func splitObject(obj string) (schema, table string) {
	parts := strings.SplitN(obj, ".", 2)
	if len(parts) == 2 {
		return parts[0], parts[1]
	}
	return "public", parts[0]
}

func pqQuoteIdent(s string) string {
	return `"` + strings.ReplaceAll(s, `"`, `""`) + `"`
}
