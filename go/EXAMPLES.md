# Примеры использования pg-sec-lab

## Быстрый старт

### 1. Генерация SQL политик

```bash
# Генерация в файл
./pg-sec-lab generate --policy policy.yaml --out output.sql

# Генерация в stdout
./pg-sec-lab generate --policy policy.yaml
```

Результат (`output.sql`):
```sql
-- Generated by pg-sec-lab
-- System: training-crm, Version: 1.0

-- Create roles
CREATE ROLE "analyst" NOLOGIN NOCREATEDB;
CREATE ROLE "support" NOLOGIN NOCREATEDB;
CREATE ROLE "reporting_app" LOGIN NOCREATEDB;
GRANT "analyst" TO "reporting_app";

-- Enable RLS on tables
ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."customers" FORCE ROW LEVEL SECURITY;
CREATE POLICY "rls_select_customers" ON "public"."customers" FOR SELECT USING (tenant_id = current_setting('app.tenant_id')::uuid);

ALTER TABLE "public"."orders" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."orders" FORCE ROW LEVEL SECURITY;
CREATE POLICY "rls_select_orders" ON "public"."orders" FOR SELECT USING (tenant_id = current_setting('app.tenant_id')::uuid);

-- Create masked views
CREATE OR REPLACE VIEW "customers_masked" AS
SELECT
  id,
  tenant_id,
  regexp_replace(email, '@.*$', '@***') AS "email"
FROM "public"."customers";

-- Grant privileges
GRANT SELECT ON "public"."orders" TO "analyst";
GRANT SELECT ON "public"."customers_masked" TO "analyst";
GRANT SELECT ON "public"."customers_masked" TO "support";
```

### 2. Проверка политик на тестовой БД

Сначала создайте тестовую БД:
```bash
# В PostgreSQL
CREATE DATABASE testdb;
```

Затем запустите проверку:
```bash
./pg-sec-lab verify \
  --policy policy.yaml \
  --dsn "postgres://postgres:password@localhost:5432/testdb?sslmode=disable"
```

Вывод:
```
2024/12/01 15:30:00 Creating test schema: pg_sec_lab_test_12345
2024/12/01 15:30:01 Applying generated policies...
2024/12/01 15:30:02 Testing RLS for tenant A...
2024/12/01 15:30:02 ✅ Tenant A sees 2 rows (expected: 2)
2024/12/01 15:30:02 Testing RLS for tenant B...
2024/12/01 15:30:02 ✅ Tenant B sees 1 row (expected: 1)
2024/12/01 15:30:02 ✅ RLS policies verified successfully
2024/12/01 15:30:02 Cleaning up test schema: pg_sec_lab_test_12345
2024/12/01 15:30:02 ✅ All verification checks passed!
```

### 3. Анализ конфигурации PostgreSQL

```bash
./pg-sec-lab analyze \
  --dsn "postgres://postgres:password@localhost:5432/mydb" \
  --out report.json
```

Пример отчёта (`report.json`):
```json
{
  "instance": {
    "version": "PostgreSQL 16.1 on x86_64-pc-linux-gnu",
    "settings": {
      "ssl": "off",
      "password_encryption": "scram-sha-256",
      "log_connections": "off",
      "log_disconnections": "off",
      "log_statement": "none"
    }
  },
  "roles": [
    {
      "name": "analyst",
      "login": false,
      "superuser": false,
      "bypassrls": false,
      "grants": [
        "SELECT ON public.orders",
        "SELECT ON public.customers_masked"
      ]
    },
    {
      "name": "postgres",
      "login": true,
      "superuser": true,
      "bypassrls": true,
      "grants": []
    },
    {
      "name": "reporting_app",
      "login": true,
      "superuser": false,
      "bypassrls": false,
      "grants": []
    }
  ],
  "tables": [
    {
      "schema": "public",
      "name": "customers",
      "rls_enabled": true
    },
    {
      "schema": "public",
      "name": "orders",
      "rls_enabled": true
    },
    {
      "schema": "public",
      "name": "legacy_table",
      "rls_enabled": false
    }
  ],
  "findings": [
    {
      "severity": "high",
      "code": "SSL_DISABLED",
      "message": "SSL is disabled on this PostgreSQL instance"
    },
    {
      "severity": "critical",
      "code": "SUPERUSER_LOGIN",
      "message": "Role postgres is a superuser with login capability"
    },
    {
      "severity": "warning",
      "code": "NO_RLS",
      "message": "Table public.legacy_table has no RLS enabled"
    },
    {
      "severity": "warning",
      "code": "BYPASS_RLS",
      "message": "Role postgres can bypass RLS policies"
    }
  ]
}
```

## Сценарии использования

### Сценарий 1: Новый проект с multi-tenancy

1. Создайте `policy.yaml` с описанием ролей и таблиц
2. Сгенерируйте SQL: `./pg-sec-lab generate --policy policy.yaml --out init.sql`
3. Примените SQL к БД: `psql -d mydb -f init.sql`
4. Проверьте на тестовой БД: `./pg-sec-lab verify --policy policy.yaml --dsn "..."`

### Сценарий 2: Аудит существующей БД

1. Проанализируйте текущую конфигурацию:
   ```bash
   ./pg-sec-lab analyze --dsn "postgres://..." --out audit.json
   ```

2. Изучите findings в отчёте
3. Создайте `policy.yaml` на основе желаемого состояния
4. Примените изменения через сгенерированный SQL

### Сценарий 3: CI/CD интеграция

```yaml
# .github/workflows/db-security.yml
name: DB Security Check

on: [push, pull_request]

jobs:
  verify-policies:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup PostgreSQL
        uses: harmon758/postgresql-action@v1
        with:
          postgresql version: '16'
          
      - name: Setup Go
        uses: actions/setup-go@v2
        with:
          go-version: '1.21'
          
      - name: Build pg-sec-lab
        run: go build -o pg-sec-lab
        
      - name: Verify policies
        run: |
          ./pg-sec-lab verify \
            --policy policy.yaml \
            --dsn "postgres://postgres:postgres@localhost:5432/postgres"
```

## Дополнительные примеры policy.yaml

### Минимальная конфигурация без RLS

```yaml
metadata:
  system: "simple-app"
  version: "1.0"

tenants:
  enabled: false

roles:
  readonly:
    login: true
    can_create_db: false
    privileges:
      - object: "public.users"
        actions: ["SELECT"]
```

### Сложная конфигурация с множественной маскировкой

```yaml
metadata:
  system: "healthcare-system"
  version: "2.0"

tenants:
  enabled: true
  setting: "app.clinic_id"

roles:
  doctor:
    login: true
    can_create_db: false
    privileges:
      - object: "public.patients"
        actions: ["SELECT", "INSERT", "UPDATE"]
      - object: "public.appointments"
        actions: ["SELECT", "INSERT", "UPDATE", "DELETE"]
  
  receptionist:
    login: true
    can_create_db: false
    privileges:
      - object: "public.patients_masked"
        actions: ["SELECT"]
      - object: "public.appointments"
        actions: ["SELECT", "INSERT"]

tables:
  public.patients:
    rls:
      enabled: true
      select_policy: "clinic_id = current_setting('app.clinic_id')::integer"
    masks:
      - column: "ssn"
        expression: "'***-**-' || substring(ssn, 8, 4)"
        exposed_as: "patients_masked"
      - column: "phone"
        expression: "substring(phone, 1, 3) || '-***-****'"
        exposed_as: "patients_masked"

  public.appointments:
    rls:
      enabled: true
      select_policy: "clinic_id = current_setting('app.clinic_id')::integer"
```

## Устранение неполадок

### Ошибка: "failed to connect to database"

Проверьте DSN строку и доступность PostgreSQL:
```bash
psql "postgres://user:password@localhost:5432/mydb"
```

### Ошибка: "validation failed: RLS enabled but select_policy is empty"

Убедитесь, что для каждой таблицы с `rls.enabled: true` указан `select_policy`.

### Ошибка при применении SQL: "role already exists"

Используйте `CREATE ROLE IF NOT EXISTS` или предварительно очистите роли:
```sql
DROP ROLE IF EXISTS analyst, support, reporting_app;
```

## Рекомендации

1. **Всегда тестируйте на копии БД** перед применением в продакшене
2. **Используйте version control** для policy.yaml
3. **Регулярно запускайте analyze** для аудита безопасности
4. **Храните DSN в переменных окружения**, не в коде
5. **Используйте SSL** для подключений к продакшен БД

## Интеграция с фронтендом

JSON-отчёт из команды `analyze` можно использовать в React-панели:

```typescript
// Example React component
interface Report {
  instance: {
    version: string;
    settings: Record<string, string>;
  };
  roles: Array<{
    name: string;
    login: boolean;
    superuser: boolean;
    bypassrls: boolean;
    grants: string[];
  }>;
  findings: Array<{
    severity: 'critical' | 'high' | 'warning';
    code: string;
    message: string;
  }>;
}

function SecurityDashboard() {
  const [report, setReport] = useState<Report | null>(null);
  
  useEffect(() => {
    fetch('/api/security-report')
      .then(res => res.json())
      .then(setReport);
  }, []);
  
  return (
    <div>
      <h1>PostgreSQL Security Report</h1>
      <FindingsList findings={report?.findings || []} />
      <RolesList roles={report?.roles || []} />
    </div>
  );
}
```
